{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"以太坊C++源码解析（一）Worker类","text":"在ethereum项目中Worker类是许多类的基类，子类们继承Worker类严格来说并不是is-a的关系，而是复用Worker类中的代码，因此可以说Worker类是一份公用代码类，那么是什么代码这么重要呢？在Worker类中我们直接来看其成员，可以看到有两个重要的成员变量： std::unique_ptr&lt;std::thread&gt; m_work; mutable std::condition_variable m_state_notifier;看到这里经验丰富的程序员们应该就能想到这个是经典的生产消费者队列的C++11实现方式，还不了解生产消费者队列的同学可以暂停一下，先搜索一下相关知识再继续。然后我们再来看两个重要的成员函数： void startWorking(); void stopWorking();这个其实就是启动和停止m_work这个线程了。在startWorking()函数内部我们能看到线程的初始化过程，线程函数体用的是lambda表达式，其中最重要的一段我列出来： try { startedWorking(); workLoop(); doneWorking(); } catch (std::exception const&amp; _e) { cwarn &lt;&lt; &quot;Exception thrown in Worker thread: &quot; &lt;&lt; _e.what(); }这个线程最重要的是执行了这三个操作，startedWorking()用于workLoop()前的准备工作,doneWorking()用于workLoop()后的收尾工资，workLoop()内部用一个循环调用了doWork()来做实际的工作： void Worker::workLoop() { while (m_state == WorkerState::Started) { if (m_idleWaitMs) this_thread::sleep_for(chrono::milliseconds(m_idleWaitMs)); doWork(); } }我们再来看这几个函数的定义： virtual void startedWorking() {} virtual void doWork() {} virtual void workLoop(); virtual void doneWorking() {}可以看到除了workLoop()有一个默认的实现外，其他函数体都是空的，子类们通过重新实现这几个函数来实现具体的功能，后面我们会看到这些子类们是怎么做的。","link":"/2019/06/18/以太坊C-源码解析（一）Worker类/"},{"title":"以太坊C++源码解析（二）大数据类型","text":"我们在C++中常用的表示整形的类型有int, long, unsigned long, int64_t等等，这些类型的长度为32位，64位，一般的情况下就能满足我们的需要了，但是在以太坊里这样的精度类型就显得捉襟见肘了，比如以太坊中常用的货币单位为Wei，而以太币1Ether=10的18次方Wei，这是一个非常大的数，普通的数据类型显然不能用了，我们需要更大的数。 #boost::multiprecision好在C++的boost库里提供了这样的数据类型，它们就存在于boost::multiprecision命名空间中，大家可以在这个网页看到定义：https://www.boost.org/doc/libs/1_65_1/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html可以看到里面定义了uint128_t，uint256_t，uint512_t甚至uint1024_t。在以太坊ethereum代码中也使用了类似的定义，不过名字不同，采用的u128表示128位无符号数，u256表示256位无符号数，以此类推，具体定义在libdevcore\\Common.h文件中。需要注意的是这种数据类型与字符串类型的转换，因为我们经常需要输出这种数值，转换位字符串会比较方便，这种类型提供了转换为std::string的方法，那就是str()函数，比如： u256 value = *******; std::string strValue = value.str();u128,u256等类型在以太坊代码中使用非常频繁，比如区块头BlockHeader.h中定义了： u256 m_gasLimit; u256 m_gasUsed; u256 m_difficulty;m_gasLimit表示gas最大值，m_gasUsed表示所使用的gas，m_difficulty表示挖矿难度。 #FixedHash类FxedHash类是一个模板类，定义于libdevcore\\FixedHash.h中，我们查看这个类定义，可以看到它就只有一个数据成员： std::array&lt;byte, N&gt; m_data;所以这就是一个封装的字节数组类，里面重载了==,!=,&gt;=等符号，还提供了一个成员hex()用于将字节数组转化为字符串数组： std::string hex();为了方便使用，该文件中还定义了一些别名，比如： using h520 = FixedHash&lt;65&gt;; using h512 = FixedHash&lt;64&gt;; using h256 = FixedHash&lt;32&gt;; using h160 = FixedHash&lt;20&gt;; using h128 = FixedHash&lt;16&gt;;h256表示32个字节大小的字节数组，其他以此类推。FixedHash类在以太坊中也经常用到，通常来表示hash值，我们还是以BlockHeader为例： h256 m_parentHash; h256 m_sha3Uncles; h256 m_stateRoot; h256 m_transactionsRoot; h256 m_receiptsRoot;m_parentHash表示父块的hash值，m_sha3Uncles表示叔块的hash值，m_stateRoot表示state树根hash，m_transactionsRoot表示交易树根hash，m_receiptsRoot表示收据树根hash。","link":"/2019/06/21/以太坊C-源码解析（二）大数据类型/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/14/hello-world/"}],"tags":[{"name":"以太坊 C++ 源码","slug":"以太坊-C-源码","link":"/tags/以太坊-C-源码/"}],"categories":[{"name":"以太坊C++源码解析","slug":"以太坊C-源码解析","link":"/categories/以太坊C-源码解析/"}]}