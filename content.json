{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"以太坊C++源码解析（一）Worker类","text":"在ethereum项目中Worker类是许多类的基类，子类们继承Worker类严格来说并不是is-a的关系，而是复用Worker类中的代码，因此可以说Worker类是一份公用代码类，那么是什么代码这么重要呢？ 在Worker类中我们直接来看其成员，可以看到有两个重要的成员变量： std::unique_ptr&lt;std::thread&gt; m_work; mutable std::condition_variable m_state_notifier;看到这里经验丰富的程序员们应该就能想到这个是经典的生产消费者队列的C++11实现方式，还不了解生产消费者队列的同学可以暂停一下，先搜索一下相关知识再继续。然后我们再来看两个重要的成员函数： void startWorking(); void stopWorking();这个其实就是启动和停止m_work这个线程了。在startWorking()函数内部我们能看到线程的初始化过程，线程函数体用的是lambda表达式，其中最重要的一段我列出来： try { startedWorking(); workLoop(); doneWorking(); } catch (std::exception const&amp; _e) { cwarn &lt;&lt; &quot;Exception thrown in Worker thread: &quot; &lt;&lt; _e.what(); }这个线程最重要的是执行了这三个操作，startedWorking()用于workLoop()前的准备工作,doneWorking()用于workLoop()后的收尾工资，workLoop()内部用一个循环调用了doWork()来做实际的工作： void Worker::workLoop() { while (m_state == WorkerState::Started) { if (m_idleWaitMs) this_thread::sleep_for(chrono::milliseconds(m_idleWaitMs)); doWork(); } }我们再来看这几个函数的定义： virtual void startedWorking() {} virtual void doWork() {} virtual void workLoop(); virtual void doneWorking() {}可以看到除了workLoop()有一个默认的实现外，其他函数体都是空的，子类们通过重新实现这几个函数来实现具体的功能，后面我们会看到这些子类们是怎么做的。","link":"/2019/06/18/以太坊C-源码解析（一）Worker类/"},{"title":"以太坊C++源码解析（三）p2p(1)","text":"整个以太坊p2p代码分为两部分，一部分是基于UDP的节点发现协议，另一部分是基于TCP的传输协议，我们先来看第一部分。这部分主要代码在libp2p\\NodeTable.h文件中。 节点发现协议是采用了类kademlia协议(kademlia-like protocol)，关于kademlia协议可以参看wiki:kademlia我们先来看看NodeTable中整体的流程图：涉及到节点发现协议的四种类型数据包： FindNode Neighbours Ping Pong #doDiscoveryNodeTable类是包含在Host类中的，Host类处理p2p模块的一个接口类，后面会谈到。我们先看NodeTable类的构造函数，里面有这段代码： m_socketPointer-&gt;connect(); doDiscovery();其中第一行的connnect()函数名称有点误导，其实是socket绑定本地端口（默认端口UDP30303），并开始接收外面的数据包。第二行的doDiscovery()函数比较重要，我们来看实现代码： m_timers.schedule(c_bucketRefresh.count(), [this](boost::system::error_code const&amp; _ec) { // ... NodeID randNodeId; crypto::Nonce::get().ref().copyTo(randNodeId.ref().cropped(0, h256::size)); crypto::Nonce::get().ref().copyTo(randNodeId.ref().cropped(h256::size, h256::size)); doDiscover(randNodeId); });无关的代码已省略。可以看到这个函数其实是启动了一个定时器，每隔c_bucketRefresh时间执行一个lambda函数，这个lambda函数产生了一个随机节点，并调用了doDiscover()函数。c_bucketRefresh定义： std::chrono::milliseconds const c_bucketRefresh = std::chrono::milliseconds(7200);得出结论，这个函数就是每隔7200ms刷新一次k桶，也就是产生一个随机节点，并调用doDiscover()。 #doDiscover我们再来看看doDiscover()函数的实现： if (_round == s_maxSteps) { LOG(m_logger) &lt;&lt; &quot;Terminating discover after &quot; &lt;&lt; _round &lt;&lt; &quot; rounds.&quot;; doDiscovery(); return; } auto nearest = nearestNodeEntries(_node); for (unsigned i = 0; i &lt; nearest.size() &amp;&amp; tried.size() &lt; s_alpha; i++) { auto r = nearest[i]; FindNode p(r-&gt;endpoint, _node); p.sign(m_secret); m_socketPointer-&gt;send(p); } m_timers.schedule(c_reqTimeout.count() * 2, [this, _node, _round, _tried](boost::system::error_code const&amp; _ec) { doDiscover(_node, _round + 1, _tried); });注：这里的代码已经经过简化，省略了部分不影响理解流程的代码。这部分代码可以分成三段，第一段和第三段代码都是用来做循环用的，并产生一个定时器，保证每隔c_reqTimeout.count() * 2时间间隔会调用一次doDiscover()，并且保证调用次数不超过s_maxSteps。 这两个常量定义如下： std::chrono::milliseconds const c_reqTimeout = std::chrono::milliseconds(300); static unsigned const s_maxSteps = boost::static_log2&lt;s_bits&gt;::value; // 值为8第二段代码比较重要，这里涉及到了一个重要的函数nearestNodeEntries()，根据字面意思是取最近的节点列表，并向这些节点发送FindNode消息。 #nearestNodeEntriesnearestNodeEntries()函数代码： vector&lt;shared_ptr&lt;NodeEntry&gt;&gt; NodeTable::nearestNodeEntries(NodeID _target) { // .. map&lt;unsigned, list&lt;shared_ptr&lt;NodeEntry&gt;&gt;&gt; found; // ... vector&lt;shared_ptr&lt;NodeEntry&gt;&gt; ret; for (auto&amp; nodes: found) for (auto const&amp; n: nodes.second) if (ret.size() &lt; s_bucketSize &amp;&amp; !!n-&gt;endpoint &amp;&amp; n-&gt;endpoint.isAllowed()) ret.push_back(n); return ret; }同样，为了避免贴大段代码影响读者的信息，我这里做了简化，只贴出重要代码。其实这段代码就是从K桶里把节点取出来，然后按距离从小到大排序，返回序列的前s_bucketSize也就是16个节点。这里巧妙的使用了std::map，并将距离作为key，我们都知道std::map是采用红黑树实现，节点默认会按key从小到大排列，因此把节点放到这个map里就自动排序了，免去了手动排序的过程。这里需要注意的是距离是逻辑上的距离，并无实际意义，只是一种节点的筛选方式，我们可以看下距离的计算方式： static int distance(NodeID const&amp; _a, NodeID const&amp; _b) { u256 d = sha3(_a) ^ sha3(_b); unsigned ret; for (ret = 0; d &gt;&gt;= 1; ++ret) {}; return ret; }可以看到这个距离只是两个节点hash做异或，然后计算二进制最高位为1的位的位数。","link":"/2019/06/21/以太坊C-源码解析（三）p2p-1/"},{"title":"以太坊C++源码解析（二）大数据类型","text":"我们在C++中常用的表示整形的类型有int, long, unsigned long, int64_t等等，这些类型的长度为32位，64位，一般的情况下就能满足我们的需要了，但是在以太坊里这样的精度类型就显得捉襟见肘了，比如以太坊中常用的货币单位为Wei，而以太币1Ether=10的18次方Wei，这是一个非常大的数，普通的数据类型显然不能用了，我们需要更大的数。 #boost::multiprecision好在C++的boost库里提供了这样的数据类型，它们就存在于boost::multiprecision命名空间中，大家可以在这个网页看到定义：https://www.boost.org/doc/libs/1_65_1/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html可以看到里面定义了uint128_t，uint256_t，uint512_t甚至uint1024_t。在以太坊ethereum代码中也使用了类似的定义，不过名字不同，采用的u128表示128位无符号数，u256表示256位无符号数，以此类推，具体定义在libdevcore\\Common.h文件中。需要注意的是这种数据类型与字符串类型的转换，因为我们经常需要输出这种数值，转换位字符串会比较方便，这种类型提供了转换为std::string的方法，那就是str()函数，比如： u256 value = *******; std::string strValue = value.str();u128,u256等类型在以太坊代码中使用非常频繁，比如区块头BlockHeader.h中定义了： u256 m_gasLimit; u256 m_gasUsed; u256 m_difficulty;m_gasLimit表示gas最大值，m_gasUsed表示所使用的gas，m_difficulty表示挖矿难度。 #FixedHash类FxedHash类是一个模板类，定义于libdevcore\\FixedHash.h中，我们查看这个类定义，可以看到它就只有一个数据成员： std::array&lt;byte, N&gt; m_data;所以这就是一个封装的字节数组类，里面重载了==,!=,&gt;=等符号，还提供了一个成员hex()用于将字节数组转化为字符串数组： std::string hex();为了方便使用，该文件中还定义了一些别名，比如： using h520 = FixedHash&lt;65&gt;; using h512 = FixedHash&lt;64&gt;; using h256 = FixedHash&lt;32&gt;; using h160 = FixedHash&lt;20&gt;; using h128 = FixedHash&lt;16&gt;;h256表示32个字节大小的字节数组，其他以此类推。FixedHash类在以太坊中也经常用到，通常来表示hash值，我们还是以BlockHeader为例： h256 m_parentHash; h256 m_sha3Uncles; h256 m_stateRoot; h256 m_transactionsRoot; h256 m_receiptsRoot;m_parentHash表示父块的hash值，m_sha3Uncles表示叔块的hash值，m_stateRoot表示state树根hash，m_transactionsRoot表示交易树根hash，m_receiptsRoot表示收据树根hash。","link":"/2019/06/21/以太坊C-源码解析（二）大数据类型/"}],"tags":[{"name":"以太坊 C++ 源码","slug":"以太坊-C-源码","link":"/tags/以太坊-C-源码/"}],"categories":[{"name":"以太坊C++源码解析","slug":"以太坊C-源码解析","link":"/categories/以太坊C-源码解析/"}]}